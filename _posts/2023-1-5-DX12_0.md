---
layout: post
title: "DX12 龙书（一）"
description: ""
date: 2023-1-5
feature_image: images/2023.1.5/0.png
tags: [DX12]
---

<!--more-->

## 环境配置

- 在配置环境时，因为示例代码对临时变量取了左值，这种行为在 VS2022 是非法的，需要将符合模式改成默认

![](../images/2023.1.5/0.png)

- 然后需要将系统改为窗口模式，否则会报无法解析的外部符号

![](../images/2023.1.5/1.png)

![](../images/2023.1.5/2.png)

## DirectXMath

- 首先需要开启 SSE2 并设置快速浮点模型 /fp:fast，SSE2 利用了单指令多数据（SIMD）寄存器，利用一条 SIMD 指令即可同时对 4 个 32 位浮点数或整数进行运算，这对于向量运算带来了巨大的遍历，不然对于一个 4维向量的加法，我们需要对每个分量逐个相加，而通过 SIMD，我们可以仅用一条 SIMD 加法指令来取代 4 条普通的标量指令，直接计算出 4D 向量的加法结果

![](../images/2023.1.5/3.png)

- DirectXMath 的核心向量类型是 XMVECTOR，它会被映射到 SIMD 硬件寄存器，由于其需要 16 位对齐，所以局部变量和全局变量是可以用的，至于类中的数据成员，建议使用 XMFLOAT2、XMFLOAT3、XMFLOAT4 类型来替代，加载函数会在运算之前将其转换位 XMVECTOR 以使用 SIMD 运算，之后通过存储函数将 XMVECTOR 转换位 XMFLOATn
- XMLoadFloatn、XMStoreFloatn、XMVectorSet、XMVectorGet
- 参数的传递这里需要注意，在调用的函数前面需要加上 XM_CALLCONV，它会根据编译器的版本确定出对应的调用约定属性，传递 XMVECTOR 参数需要注意以下规则：前 3 个用 FXMVECTOR，第 4 个用 GXMVECTOR，第 5、6 个用 HXMVECTOR，其余的用 CXMVECTOR，构造函数则是前 3 个用 FXMVECTOR，其余参数用 CXMVECTOR，同时对构造函数不适用 XM_CALLCONV 注解。这些规则是对于输入参数而言的，输出不会占用 SSE/SSE2 寄存器
- 常量向量表示为 XMVECTORF32、XMVECTORU32
- XM_PI、XM_1DIVPI、XMConvertToRadians、XMConvertToDegrees、XMMin、XMMax
- XMVectornLength、XMVectornDot、XMVectornCross、XMVectornNormalize、XMVectornOrthogonal、XMVectornAngleBetweenVectors、XMVectornComponentsFromNarmal、XMVectornEqual、XMVectornNotEqual
- 在比较浮点数的时候，一定要注意误差，数值误差是可以积累的，通常可以定义一个 Epsilon 常量作为容差，使用近似相等函数比较 XMVectornNearEqual
- cout.setf() 的作用是通过设置格式标志来控制输出形式，如 boolalpha 可以使用单词true 和 false 进行输入/输出的布尔值
- XMVerifyCPUSupport 如果 DirectXMath 库支持给定的平台，则返回 true;如果不是，则为 false
- XMVectorSet 使用 4 个浮点值创建 vector
- XMVector3ComponentsFromNormal 使用引用法向量，将三维向量拆分为并行和垂直于正态的组件
- XMVectorSwizzle 重排向量各分量，XMVectorSplatZ 将向量的 z 组件复制到所有组件
- 变换矩阵一定意义上也可以解释为坐标变换矩阵

## DirectX3D 基础知识

- DX 层和硬件驱动层会协作将 DX 命令转换为系统中 GPU 可以执行的本地机器指令
- 组件对象模型（COM）可以被视为一种接口，COM 对象会统计引用次数，COM 接口的所有功能都是从 IUnknown 这个 COM 接口继承而来的
- Windows 运行时库（WRL）提供了 Microsoft::WRL::ComPtr 类，用来表示 COM 对象的智能指针，Get 返回一个指向此底层 COM 接口的指针，GetAddressOf 返回指向此底层 COM 接口指针的地址，Reset 将此 ComPtr 实例设置为 nullptr
- COM 接口都以大写字母 I 开头
- 2D texture 是一种由数据元素构成的矩阵，可以存储 DXGI_FORMAT 枚举类型中描述的特定格式的数据元素，也有 TYPELESS 格式，用来预留内存，待纹理被绑定到渲染流水线之后再具体解释它的数据类型
- 深度缓冲区也是一种纹理，格式包括 DXGI_FORMAT_D32_FLOAT_S8X24_UINT 等，一个应用程序不一定要用到模板缓冲区，但一经使用，深度缓冲区将总是与模板缓冲区如影随形
- 资源需要被绑定到渲染流水线上，需要通过描述符的对象来对它间接引用，描述符为 GPU 解释资源，还可以绑定资源中的局部数据
- 描述符堆中存有一系列描述符，每一种类型的描述符都需要创建单独的描述符堆，一个资源可能绑定到渲染流水线的不同阶段，对于每个阶段都需要设置独立的描述符，一般在初始化时创建描述符
- 超级采样 SSAA 多重采样 MSAA
- DXGI_SAMPLE_DESC D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS ID3D12Device::CheckFeatureSupport
- 在创建交换链缓冲区和深度缓冲区时都需要填写 DXGI_SAMPLE_DESC 结构体，并且在创建后台缓冲区和深度缓冲区时，多重采样的有关设置一定要相同
- DXGI 图形基础结构，设计 DXGI 的基本理念是使多种图形 API 中所共有的底层任务能借助一组通用 API 来进行处理，支持一些常用的图形功能如切换全屏模式、枚举显示适配器等，还定义了 Direct3D 支持的各种表面格式信息
- IDXGIFactory 主要用来创建 IDXGISwapChain 以及枚举显示适配器，显示适配器是一种硬件设备如独立显卡，也有软件显示适配器 IDXGIAdapter
- 显示输出 IDXGIOutput，每个适配器都与一组显示输出相关联，每种显示设备都有一系列它所支持的显示模式 DXGI_MODE_DESC，可以获得某个显示输出对此格式所支持的全部显示模式 IDXGIOutput->GetDisplayModeList，所指定的显示模式要与显示器支持的显示模式匹配
- ID3D12Device::CheckFeatureSupport 检测当前图形驱动对功能的支持
- 应用程序通过控制资源在显存中的去留，主动管理资源的驻留情况
- 每个 GPU 至少维护着一个命令队列 ID3D12CommandQueue，CPU 通过命令列表 ID3D12CommandLis 将命令提交到命令队列中，但不一定会被立即执行，DX12 采用延迟渲染 “命令列表->命令队列” 模型，ID3D12CommandQueue::ExecuteCommandLists 将命令列表里的命令添加到命令队列之中，提交之前一定要将命令列表关闭 ->Close()
- ID3D12CommandAllocator 内存管理类接口，记录在命令列表内的命令，实际上是存储在与之关联的命令分配器上，提交之后命令队列会引用分配器里的命令，可以创建出多个关联于同一命令分配器的命令列表，但是不能同时用它们来记录命令，因为需要保证命令的添加顺序。当创建或重置一个命令列表的时候，它会处于一种打开的状态，所以为同一个命令分配器连续创建两个命令列表时会报错
- 提交之后使用 Reset 可以安全复用命令列表占用的相关底层内存来记录新的命令集，恢复为刚创建时的初始状态。也可以用 Reset 复用命令分配器中的内存，由于命令队列可能引用命令分配器中的数据，在不确定 GPU 执行完命令之前不要重置命令分配器


## 小结

## References