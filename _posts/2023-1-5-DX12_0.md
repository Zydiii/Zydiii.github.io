---
layout: post
title: "DX12 龙书（一）"
description: ""
date: 2023-1-5
feature_image: images/2023.1.5/0.png
tags: [DX12]
---

<!--more-->

## 环境配置

- 在配置环境时，因为示例代码对临时变量取了左值，这种行为在 VS2022 是非法的，需要将符合模式改成默认

![](../images/2023.1.5/0.png)

- 然后需要将系统改为窗口模式，否则会报无法解析的外部符号

![](../images/2023.1.5/1.png)

![](../images/2023.1.5/2.png)

## DirectXMath

- 首先需要开启 SSE2 并设置快速浮点模型 /fp:fast，SSE2 利用了单指令多数据（SIMD）寄存器，利用一条 SIMD 指令即可同时对 4 个 32 位浮点数或整数进行运算，这对于向量运算带来了巨大的遍历，不然对于一个 4维向量的加法，我们需要对每个分量逐个相加，而通过 SIMD，我们可以仅用一条 SIMD 加法指令来取代 4 条普通的标量指令，直接计算出 4D 向量的加法结果

![](../images/2023.1.5/3.png)

- DirectXMath 的核心向量类型是 XMVECTOR，它会被映射到 SIMD 硬件寄存器，由于其需要 16 位对齐，所以局部变量和全局变量是可以用的，至于类中的数据成员，建议使用 XMFLOAT2、XMFLOAT3、XMFLOAT4 类型来替代，加载函数会在运算之前将其转换位 XMVECTOR 以使用 SIMD 运算，之后通过存储函数将 XMVECTOR 转换位 XMFLOATn
- XMLoadFloatn、XMStoreFloatn、XMVectorSet、XMVectorGet
- 参数的传递这里需要注意，在调用的函数前面需要加上 XM_CALLCONV，它会根据编译器的版本确定出对应的调用约定属性，传递 XMVECTOR 参数需要注意以下规则：前 3 个用 FXMVECTOR，第 4 个用 GXMVECTOR，第 5、6 个用 HXMVECTOR，其余的用 CXMVECTOR，构造函数则是前 3 个用 FXMVECTOR，其余参数用 CXMVECTOR，同时对构造函数不适用 XM_CALLCONV 注解。这些规则是对于输入参数而言的，输出不会占用 SSE/SSE2 寄存器
- 常量向量表示为 XMVECTORF32、XMVECTORU32
- XM_PI、XM_1DIVPI、XMConvertToRadians、XMConvertToDegrees、XMMin、XMMax
- XMVectornLength、XMVectornDot、XMVectornCross、XMVectornNormalize、XMVectornOrthogonal、XMVectornAngleBetweenVectors、XMVectornComponentsFromNarmal、XMVectornEqual、XMVectornNotEqual
- 在比较浮点数的时候，一定要注意误差，数值误差是可以积累的，通常可以定义一个 Epsilon 常量作为容差，使用近似相等函数比较 XMVectornNearEqual
- cout.setf() 的作用是通过设置格式标志来控制输出形式，如 boolalpha 可以使用单词true 和 false 进行输入/输出的布尔值
- XMVerifyCPUSupport 如果 DirectXMath 库支持给定的平台，则返回 true;如果不是，则为 false
- XMVectorSet 使用 4 个浮点值创建 vector
- XMVector3ComponentsFromNormal 使用引用法向量，将三维向量拆分为并行和垂直于正态的组件
- XMVectorSwizzle 重排向量各分量，XMVectorSplatZ 将向量的 z 组件复制到所有组件
- 变换矩阵一定意义上也可以解释为坐标变换矩阵

## DirectX3D 基础知识

- DX 层和硬件驱动层会协作将 DX 命令转换为系统中 GPU 可以执行的本地机器指令
- 组件对象模型（COM）可以被视为一种接口，COM 对象会统计引用次数，COM 接口的所有功能都是从 IUnknown 这个 COM 接口继承而来的
- Windows 运行时库（WRL）提供了 Microsoft::WRL::ComPtr 类，用来表示 COM 对象的智能指针，Get 返回一个指向此底层 COM 接口的指针，GetAddressOf 返回指向此底层 COM 接口指针的地址，Reset 将此 ComPtr 实例设置为 nullptr
- COM 接口都以大写字母 I 开头
- 2D texture 是一种由数据元素构成的矩阵，可以存储 DXGI_FORMAT 枚举类型中描述的特定格式的数据元素，也有 TYPELESS 格式，用来预留内存，待纹理被绑定到渲染流水线之后再具体解释它的数据类型
- 深度缓冲区也是一种纹理，格式包括 DXGI_FORMAT_D32_FLOAT_S8X24_UINT 等，一个应用程序不一定要用到模板缓冲区，但一经使用，深度缓冲区将总是与模板缓冲区如影随形
- 资源需要被绑定到渲染流水线上，需要通过描述符的对象来对它间接引用，描述符为 GPU 解释资源，还可以绑定资源中的局部数据
- 描述符堆中存有一系列描述符，每一种类型的描述符都需要创建单独的描述符堆，一个资源可能绑定到渲染流水线的不同阶段，对于每个阶段都需要设置独立的描述符，一般在初始化时创建描述符
- 超级采样 SSAA 多重采样 MSAA
- DXGI_SAMPLE_DESC D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS ID3D12Device::CheckFeatureSupport
- 在创建交换链缓冲区和深度缓冲区时都需要填写 DXGI_SAMPLE_DESC 结构体，并且在创建后台缓冲区和深度缓冲区时，多重采样的有关设置一定要相同


## 小结

## References