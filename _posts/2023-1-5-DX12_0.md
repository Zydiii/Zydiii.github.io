---
layout: post
title: "DX12 龙书（一）"
description: ""
date: 2023-1-5
feature_image: images/2023.1.5/0.png
tags: [DX12]
---

<!--more-->

## 环境配置

- 在配置环境时，因为示例代码对临时变量取了左值，这种行为在 VS2022 是非法的，需要将符合模式改成默认

![](../images/2023.1.5/0.png)

- 然后需要将系统改为窗口模式，否则会报无法解析的外部符号

![](../images/2023.1.5/1.png)

![](../images/2023.1.5/2.png)

## DirectXMath

- 首先需要开启 SSE2 并设置快速浮点模型 /fp:fast，SSE2 利用了单指令多数据（SIMD）寄存器，利用一条 SIMD 指令即可同时对 4 个 32 位浮点数或整数进行运算，这对于向量运算带来了巨大的遍历，不然对于一个 4维向量的加法，我们需要对每个分量逐个相加，而通过 SIMD，我们可以仅用一条 SIMD 加法指令来取代 4 条普通的标量指令，直接计算出 4D 向量的加法结果

![](../images/2023.1.5/3.png)

- DirectXMath 的核心向量类型是 XMVECTOR，它会被映射到 SIMD 硬件寄存器，由于其需要 16 位对齐，所以局部变量和全局变量是可以用的，至于类中的数据成员，建议使用 XMFLOAT2、XMFLOAT3、XMFLOAT4 类型来替代，加载函数会在运算之前将其转换位 XMVECTOR 以使用 SIMD 运算，之后通过存储函数将 XMVECTOR 转换位 XMFLOATn
- XMLoadFloatn、XMStoreFloatn、XMVectorSet、XMVectorGet
- 参数的传递这里需要注意，在调用的函数前面需要加上 XM_CALLCONV，它会根据编译器的版本确定出对应的调用约定属性，传递 XMVECTOR 参数需要注意以下规则：前 3 个用 FXMVECTOR，第 4 个用 GXMVECTOR，第 5、6 个用 HXMVECTOR，其余的用 CXMVECTOR，构造函数则是前 3 个用 FXMVECTOR，其余参数用 CXMVECTOR，同时对构造函数不适用 XM_CALLCONV 注解。这些规则是对于输入参数而言的，输出不会占用 SSE/SSE2 寄存器
- 常量向量表示为 XMVECTORF32、XMVECTORU32
- XM_PI、XM_1DIVPI、XMConvertToRadians、XMConvertToDegrees、XMMin、XMMax
- XMVectornLength、XMVectornDot、XMVectornCross、XMVectornNormalize、XMVectornOrthogonal、XMVectornAngleBetweenVectors、XMVectornComponentsFromNarmal、XMVectornEqual、XMVectornNotEqual
- 在比较浮点数的时候，一定要注意误差，数值误差是可以积累的，通常可以定义一个 Epsilon 常量作为容差，使用近似相等函数比较 XMVectornNearEqual
- cout.setf() 的作用是通过设置格式标志来控制输出形式，如 boolalpha 可以使用单词true 和 false 进行输入/输出的布尔值
- XMVerifyCPUSupport 如果 DirectXMath 库支持给定的平台，则返回 true;如果不是，则为 false
- XMVectorSet 使用 4 个浮点值创建 vector
- XMVector3ComponentsFromNormal 使用引用法向量，将三维向量拆分为并行和垂直于正态的组件
- XMVectorSwizzle 重排向量各分量，XMVectorSplatZ 将向量的 z 组件复制到所有组件
- 变换矩阵一定意义上也可以解释为坐标变换矩阵

## DirectX3D 基础知识

- DX 层和硬件驱动层会协作将 DX 命令转换为系统中 GPU 可以执行的本地机器指令
- 组件对象模型（COM）可以被视为一种接口，COM 对象会统计引用次数，COM 接口的所有功能都是从 IUnknown 这个 COM 接口继承而来的
- Windows 运行时库（WRL）提供了 Microsoft::WRL::ComPtr 类，用来表示 COM 对象的智能指针，Get 返回一个指向此底层 COM 接口的指针，GetAddressOf 返回指向此底层 COM 接口指针的地址，Reset 将此 ComPtr 实例设置为 nullptr
- COM 接口都以大写字母 I 开头
- 2D texture 是一种由数据元素构成的矩阵，可以存储 DXGI_FORMAT 枚举类型中描述的特定格式的数据元素，也有 TYPELESS 格式，用来预留内存，待纹理被绑定到渲染流水线之后再具体解释它的数据类型
- 深度缓冲区也是一种纹理，格式包括 DXGI_FORMAT_D32_FLOAT_S8X24_UINT 等，一个应用程序不一定要用到模板缓冲区，但一经使用，深度缓冲区将总是与模板缓冲区如影随形
- 资源需要被绑定到渲染流水线上，需要通过描述符的对象来对它间接引用，描述符为 GPU 解释资源，还可以绑定资源中的局部数据
- 描述符堆中存有一系列描述符，每一种类型的描述符都需要创建单独的描述符堆，一个资源可能绑定到渲染流水线的不同阶段，对于每个阶段都需要设置独立的描述符，一般在初始化时创建描述符
- 超级采样 SSAA 多重采样 MSAA
- DXGI_SAMPLE_DESC D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS ID3D12Device::CheckFeatureSupport
- 在创建交换链缓冲区和深度缓冲区时都需要填写 DXGI_SAMPLE_DESC 结构体，并且在创建后台缓冲区和深度缓冲区时，多重采样的有关设置一定要相同
- DXGI 图形基础结构，设计 DXGI 的基本理念是使多种图形 API 中所共有的底层任务能借助一组通用 API 来进行处理，支持一些常用的图形功能如切换全屏模式、枚举显示适配器等，还定义了 Direct3D 支持的各种表面格式信息
- IDXGIFactory 主要用来创建 IDXGISwapChain 以及枚举显示适配器，显示适配器是一种硬件设备如独立显卡，也有软件显示适配器 IDXGIAdapter
- 显示输出 IDXGIOutput，每个适配器都与一组显示输出相关联，每种显示设备都有一系列它所支持的显示模式 DXGI_MODE_DESC，可以获得某个显示输出对此格式所支持的全部显示模式 IDXGIOutput->GetDisplayModeList，所指定的显示模式要与显示器支持的显示模式匹配
- ID3D12Device::CheckFeatureSupport 检测当前图形驱动对功能的支持
- 应用程序通过控制资源在显存中的去留，主动管理资源的驻留情况
- 每个 GPU 至少维护着一个命令队列 ID3D12CommandQueue，CPU 通过命令列表 ID3D12CommandLis 将命令提交到命令队列中，但不一定会被立即执行，DX12 采用延迟渲染 “命令列表->命令队列” 模型，ID3D12CommandQueue::ExecuteCommandLists 将命令列表里的命令添加到命令队列之中，提交之前一定要将命令列表关闭 ->Close()
- ID3D12CommandAllocator 内存管理类接口，记录在命令列表内的命令，实际上是存储在与之关联的命令分配器上，提交之后命令队列会引用分配器里的命令，可以创建出多个关联于同一命令分配器的命令列表，但是不能同时用它们来记录命令，因为需要保证命令的添加顺序。当创建或重置一个命令列表的时候，它会处于一种打开的状态，所以为同一个命令分配器连续创建两个命令列表时会报错
- 提交之后使用 Reset 可以安全复用命令列表占用的相关底层内存来记录新的命令集，恢复为刚创建时的初始状态。也可以用 Reset 复用命令分配器中的内存，由于命令队列可能引用命令分配器中的数据，在不确定 GPU 执行完命令之前不要重置命令分配器
- 为了使 CPU 和 GPU 之间达成同步，需要设置围栏 ID3D12Fence，每个围栏维护着一个 UINT64 类型的值，ID3D12CommandQueue::Signal 从 GPU 端设置围栏值，ID3D12Fence::Signal 方法从 CPU 端设置围栏值
- 为了防止读写同一资源发生冲突，这种现象称为资源冒险，为资源添加状态，不同的行为将改变资源的状态，如渲染目标状态、着色器资源状态，通过命令列表设置转换资源屏障D3D12_RESOURCE_BARRIER，资源屏障转换可以看作是一条告知 GPU 某资源状态正在进行转换的命令，CD3D12_RESOURCE_BARRIER::Transition
- CD3DX12 作为前缀表示一些 DX12 中结构的扩展辅助结构变体，定义在 d3dx12.h
- 每个线程通常只使用各自的命令列表，仅使用属于自己的命令分配器，多线程可以同时访问同一命令队列，也能够同时调用它的方法，可以同时向命令队列提交它们自己所生成的命令列表

## 初始化 Direct3D

- 创建设备 ID3D12Device
- 创建围栏并获取描述符大小
- 检测对 MSAA 质量级别的支持
- 创建命令队列和命令列表
- 描述并创建交换链
- 创建描述符堆，RVT、DSV
- 创建渲染目标视图并将其绑定到流水线阶段，例如后台缓冲区绑定到流水线的输出合并阶段
- 创建深度/模板缓冲区及其视图，创建资源和堆，并将该资源提交到堆中
- 设置视口，相对于后台缓冲区的绘制范围，将场景绘至整个后台缓冲区
- 设置裁剪矩形，在此矩形外的像素都将被剔除

## 计时与动画

- 帧率 每秒刷新的帧数，性能计时器 <windows.h> QueryPerformanceCounter 获取性能计时器测量的当前时刻值，QueryPerformanceFrequency 获取性能计时器的频率，通过相对差值获得代码执行期间的时间
- 在不同处理器上计时可能得到不同的结果，可以通过 SetThreadAffinityMask 防止应用程序的主线程切换到其他的处理器上去执行
- 游戏计时器类 Tick() 用于更新 mDeltaTime、mPrevTime，Reset() 需要重新设置 mBaseTime、mPrevTime、mStopTime、mStopped
- 总时间需要记录 mBaseTime、mPausedTime、mStopTime、mCurrTime，需要减去中间暂停的时间

## 框架

- D3DApp 负责创建应用程序主窗口、运行程序消息循环、处理窗口消息、初始化 Direct3D，同时将部分初始化、消息处理、创建描述符堆、修改大小、更新、绘制等作为虚函数可供改写自定义
- 消息处理 WM_ACTIVATE、WM_SIZE、WM_EXITSIZEMOVE、WM_DESTROY、WM_MENUCHAR、WM_GETMINMAXINFO、WMLBUTTONDOWN 等
- 宏定义中 # 表示字符串化操作符，将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。__FILE__、__LINE__ 会定位到出错函数的文件与行

## 渲染流水线

- 渲染流水线是种模型，将 3D 场景变换至 2D 场景的处理流程抽象分离为不同的流水线阶段，供用户使用，本质即指令从 CPU 端的应用程序层发送至 Direct3D 运行时、驱动层及至 GPU 端，资源数据在内存与显存间游走，最后是 GPU 内部各种引擎、缓存、命令队列等根据指令配合运作将数据转化为显示器可视信号
- XMVECTOR 可以描述颜色 XMCOLOR 有 32 位颜色，也有 128 位颜色
- 渲染流水线是以摄像机为观察视角而生成 2D 图像的一系列完整步骤
- 1）输入装配阶段 IA 从显存中读取几何数据，再将它们装配为几何图元，通过索引定义如何将顶点装配在一起构成图元 2）顶点着色器阶段 VS 输入输出都是单个顶点，涉及局部空间到世界空间到观察空间，然后投影和齐次裁剪，规格化设备坐标、归一化深度值 3）曲面细分阶段 可以实现 LOD 4）几何着色器阶段 GS 输入是完整的图元，可以创建或销毁几何体 5）裁剪 6）光栅化阶段 RS 视口变换、背面剔除、顶点属性插值 7）像素着色器阶段 PS 根据顶点的插值属性作为输入来计算出对应的像素颜色 8）输出合并阶段 OM 一些像素可能会被丢弃，剩下的像素片段将会被写入后台缓冲区，也可以进行混合操作

## 利用 Direct3D 绘制几何体

- 顶点与输入布局 首先构建自定义的顶点格式，然后通过输入布局描述提供该顶点结构体的描述 D3D12_INPUT_LAYOUT_DESC D3D12_INPUT_ELEMENT_DESC
- 顶点缓冲区 缓冲区是一种 GPU 资源，存储顶点的缓冲区叫顶点缓冲区，先使用 D3D12_RESOURCE_DESC 描述缓冲区资源，然后使用 ID3D12Device::CreateCommittedResouce 创建 ID3D12Resource 对象，对于静态几何体我们将顶点缓冲区置于默认堆 D3D12_HEAP_TYPE_DEFAULT，但 CPU 不能直接向默认堆写数据，需要创建上传缓冲区 D3D12_HEAP_TYPE_UPLOAD，通过把资源提交到上传堆，才得以将数据从 CPU 复制到 GPU 显存中，先从系统内存复制到上传缓冲区，再把顶点数据从上传缓冲区复制到真正的顶点缓冲区。为了将顶点缓冲区绑定到渲染流水线上，需要创建顶点缓冲区视图，无需创建描述符堆。IASetVertexBuffers
- ID3D12GraphicsCommandList::DrawInstanced 绘制顶点，需要先利用 IASetPrimitiveTopology 设置拓扑
- 索引和索引缓冲区 创建索引缓冲区、索引缓冲区视图 IASetIndexBuffer DrawIndexedInstanced 对于一个缓冲区存储了多种对象的数据时，需要指明基准顶点地址
- 顶点着色器 输入签名 SV_POSITION SV 表明是系统值 连接输入布局描述符与输入签名
- 像素着色器 接收插值数据，针对每一个像素片段运行 像素片段可能会在像素着色器中被裁掉，使用 clip 可以使指定的像素片段在后续的处理流程中被忽略掉。在确定后台缓冲区某一像素的过程中，可能会存在多个候选的像素片段。SV_TARGET 表示该返回值的类型应当与渲染目标格式匹配，该输出值会被存于渲染目标之中
- 常量缓冲区 常量缓冲区也是一种 GPU 资源 cbuffer 常量缓冲区通常由 CPU 每帧更新一次，创建到上传堆，大小必须为硬件最小分配 256B 的整数倍。常量缓冲区视图绑定到存有物体响应常量数据的缓冲区子区域。CPU 更新数据要先获得指向欲更新资源数据的指针 Map Unmap 常量缓冲区描述符 D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV 这种堆可以混合存储常量缓冲区描述符、着色器资源描述符和无序访问描述符。在创建供着色器程序访问资源的描述符时，要把标志指定为 DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE 先填写 D3D12_CONSTANT_BUFFER_VIEW_DESC，再调用 CreateConstantBufferView 便可创建常量缓冲区 根签名和描述符表 根签名：在执行绘制命令之前，资源会被映射到着色器的对应输入寄存器 ID3D12RootSignature 根参数可以是根常量、根描述符、描述符表，描述符表指定的是描述符堆中存有描述符的一块连续区域。SetGraphicsRootDescriptorTable 令描述符表与渲染流水线相绑定
- 编译着色器 着色器程序必须先被编译为一种可移植的字节码，图形驱动程序将获取这些字节码，并将其重新编译为针对当前系统 GPU 所优化的本地指令 D3DCompileFromFile 也可以离线编译，提前生成 .cso，然后使用 LoadBinary 加载字节码
- 光栅器状态 可以设置绘制模式、剔除操作等
- 流水线状态对象 输入布局描述、着色器、光栅器状态等控制图形流水线状态的对象被统称为流水线状态对象 ID3D12PipelineState D3D12_GRAPHICS_PIPELINE_STATE_DESC 集合大量流水线状态信息，应在初始化期间就生成 PSO
- Direct3D 实质上就是一种状态机，里面的事物会保持它们各自的状态，直到我们将其改变。可以定义几何图形辅助结构体，存储顶点缓冲区、索引缓冲区、几何体数据等结构方便使用

## Draw Box Demo

### D3DApp::InitMainWindow() 初始化并绘制窗口

- HINSTANCE 是一个实例句柄，本质就是个无符号长整型，HWND 是一个窗口句柄，是唯一的标识，当窗口被创建的时候会分配一个句柄，这个句柄是唯一的，可以通过这个句柄找到窗口的各种属性，所以我们新建的类 D3DApp 的成员变量中需要包含这两个句柄

```C++
HINSTANCE mhAppInst = nullptr; // application instance handle
HWND      mhMainWnd = nullptr; // main window handle
```

- 对于 HINSTANCE hInstance 来说，它来自 WinMain() 的默认输入，D3DApp 进行记录，用处有两点，一个是创建 WNDCLASS 时需要设置实例句柄，一个是创建窗口句柄 HWND 时需要传入实例句柄
- WNDCLASS 定义了窗口的类型，包括样式、背景、图标、消息处理、实例句柄、类别名称等，定义好之后需要 RegisterClass() 对当前的窗口类进行注册，之后在能在 CreateWindow 中通过名称调用该类型

```C++
typedef struct tagWNDCLASSEXW  {
    UINT        cbSize;                // 窗口类结构体的内存大小(new)    
    UINT        style;                 // 类风格
    WNDPROC     lpfnWndProc;           // 窗口的处理过程
    int         cbClsExtra;            // 指定紧随在 WNDCLASS 数据结构后分配的字节数
    int         cbWndExtra;            // 指定紧随在窗口实例之后分配的字节数            
    HINSTANCE   hInstance;             // 窗口类所在模块的实例句柄
    HICON       hIcon;                 // 窗口类的图标
    HCURSOR     hCursor;               // 窗口类的光标
    HBRUSH      hbrBackground;         // 窗口类的背景画刷
    LPCWSTR     lpszMenuName;          // 窗口类的菜单资源名
    LPCWSTR     lpszClassName;         // 窗口类的名称
    HICON       hIconSm;               // 窗口类的任务栏图标(new)    
} WNDCLASSW
WNDCLASS wc;
wc.style         = CS_HREDRAW | CS_VREDRAW;
wc.lpfnWndProc   = MainWndProc; 
wc.cbClsExtra    = 0;
wc.cbWndExtra    = 0;
wc.hInstance     = mhAppInst;
wc.hIcon         = LoadIcon(0, IDI_APPLICATION);
wc.hCursor       = LoadCursor(0, IDC_ARROW);
wc.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
wc.lpszMenuName  = 0;
wc.lpszClassName = L"MainWnd";
if( !RegisterClass(&wc) )
{
	MessageBox(0, L"RegisterClass Failed.", 0, 0);
	return false;
}
```

- 创建窗口句柄需要用 CreateWindow()，它需要设置窗口类的名称，需要是提前注册好的 WNDCLASS 的名称，设置标题名称、大小、位置、实例句柄等，在设置窗口大小时，用到了 AdjustWindowRect()，根据所需的客户端矩形大小计算窗口矩形的所需大小，然后，窗口矩形可以传递给 CreateWindow 函数，以创建其工作区为所需大小的窗口

```C++
RECT R = { 0, 0, mClientWidth, mClientHeight };
AdjustWindowRect(&R, WS_OVERLAPPEDWINDOW, false);
int width  = R.right - R.left;
int height = R.bottom - R.top;
mhMainWnd = CreateWindow(L"MainWnd", mMainWndCaption.c_str(), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, width, height, 0, 0, mhAppInst, 0); 
```

- 创建好窗口句柄之后窗口还没有显示出来，需要是用 ShowWindow() 设定窗口的显示状态，并且用 UpdateWindow() 刷新一下窗口（不过我注释掉这句话窗口仍然会显示）

```C++
ShowWindow(mhMainWnd, SW_SHOW);
UpdateWindow(mhMainWnd);
```

- 那么总体来说，创建一个窗口主要就涉及了三个步骤，第一步创建并注册窗口类，第二步创建窗口句柄，第三步设置窗口显示状态并刷新

### D3DApp::InitDirect3D() 初始化 Direct3D

- 在创建 Device 之前可以打开调试接口 ID3D12Debug，此接口是通过从 D3D12GetDebugInterface 查询获取的，使用 EnableDebugLayer 启用调试层

```C++
#if defined(DEBUG) || defined(_DEBUG) 
	// Enable the D3D12 debug layer.
{
	ComPtr<ID3D12Debug> debugController;
	ThrowIfFailed(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)));
	debugController->EnableDebugLayer();
}
#endif
```

- IDXGIFactory4 提供创建 DXGI 对象的相关方法，需要使用 CreateDXGIFactory1 进行创建

```C++
ThrowIfFailed(CreateDXGIFactory1(IID_PPV_ARGS(&mdxgiFactory)));
```

- DXGI 图形基础结构，主要目标是管理独立于 DirectX 图形运行时的低级别任务，如硬件设备的枚举、向输出呈现呈现的帧、控制伽玛和管理全屏转换。适配器是计算机的硬件和软件功能的抽象。 计算机上通常有许多适配器。 某些设备在硬件 (（如视频卡) ）中实现，有些设备在软件 (（如 Direct3D 参考光栅器) ）中实现。 适配器实现图形应用程序使用的功能。 
- HRESULT 常被用作 COM 调用的返回值，其中最常用的是S_OK、S_FALSE、E_FAIL

```C++
S_OK 操作成功，调用成功。需要用 Smemory。EnumWarpAdapterUCCEEDED(hr) 来判断
#define SUCCEEDED(hr) (((HRESULT)(hr)) >= 0)
S_FALSE 函数调用成功，可以处理有问题。需要用（hr == S_FALSE）来判断
E_FAIL 未指定的失败，一般来讲是函数调用错误。需要用（hr == E_FAIL） 来判断。
#define FAILED(hr) (((HRESULT)(hr)) < 0)
```

- 绘制需要一个绘制的环境。绘制环境是在代码层对硬件环境的一种抽象，所有的绘制都是在这个绘制环境中完成的，可以说绘制环境才是我们的“硬件”。DX12对绘制环境的抽象是ID3D12Device。
- ID3D12Device 表示虚拟适配器;它用于创建命令分配器、命令列表、命令队列、围栏、资源、管道状态对象、堆、根签名、采样器和许多资源视图。
- 在创建Device的时候，我们要做两手准备。一是直接创建默认显示适配器的Device，二是如果这个默认显示适配器的Device没法创建，那么就创建一个软件适配器的Device。IDXGIAdapter 是指显示适配器，包括 GPUs, DACs and video memory。EnumWarpAdapter 用于枚举适配器，主要是在使用WARP渲染器时用到。

```C++
// 创建绘制环境，虚拟适配器
// 尝试创建默认适配器
HRESULT hardwareResult = D3D12CreateDevice(
	nullptr,             // default adapter
	D3D_FEATURE_LEVEL_11_0,
	IID_PPV_ARGS(&md3dDevice));

// 失败就创建 WARP 软件适配器
if(FAILED(hardwareResult))
{
	ComPtr<IDXGIAdapter> pWarpAdapter;
	ThrowIfFailed(mdxgiFactory->EnumWarpAdapter(IID_PPV_ARGS(&pWarpAdapter)));

	ThrowIfFailed(D3D12CreateDevice(
		pWarpAdapter.Get(),
		D3D_FEATURE_LEVEL_11_0,
		IID_PPV_ARGS(&md3dDevice)));
}
```

- ID3D12Fence 是用来让 CPU 和 GPU 的同步的 fence，通过 ID3D12Device::CreateFence 来创建

```C++
ThrowIfFailed(md3dDevice->CreateFence(0, D3D12_FENCE_FLAG_NONE,
	IID_PPV_ARGS(&mFence)));
```

- 为了能对描述符堆进行正确地索引，需要使用 ID3D12Device::GetDescriptorHandleIncrementSize 提前记录下描述符堆的句柄增量大小，描述符堆的类型比如：D3D12_DESCRIPTOR_HEAP_TYPE_RTV render-target view，D3D12_DESCRIPTOR_HEAP_TYPE_DSV depth-stencil view，D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV constant-buffer, shader-resource, and unordered-access views

```C++
mRtvDescriptorSize = md3dDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
mDsvDescriptorSize = md3dDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);
mCbvSrvUavDescriptorSize = md3dDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
```

- 然后检查 4X MSAA 质量的支持情况

```C++
D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS msQualityLevels;
msQualityLevels.Format = mBackBufferFormat;
msQualityLevels.SampleCount = 4;
msQualityLevels.Flags = D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE;
msQualityLevels.NumQualityLevels = 0;
ThrowIfFailed(md3dDevice->CheckFeatureSupport(
	D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS,
	&msQualityLevels,
	sizeof(msQualityLevels)));

m4xMsaaQuality = msQualityLevels.NumQualityLevels;
assert(m4xMsaaQuality > 0 && "Unexpected MSAA quality level.");
```

- Debug 状态下可以输出所有的 adapter 信息，使用 IDXGIFactory::EnumAdapters 枚举 adapter，使用 IDXGIAdapter::EnumOutputs 枚举适配器的输出，使用 IDXGIOutput::GetDisplayModeList 获取与请求的格式和其他输入选项匹配的显示模式。遍历逻辑就是枚举适配器->枚举每个适配器的输出->枚举匹配格式的显示模式

```C++
void D3DApp::LogAdapters()
{
    UINT i = 0;
    IDXGIAdapter* adapter = nullptr;
    std::vector<IDXGIAdapter*> adapterList;
    while(mdxgiFactory->EnumAdapters(i, &adapter) != DXGI_ERROR_NOT_FOUND)
    {
        DXGI_ADAPTER_DESC desc;
        adapter->GetDesc(&desc);

        std::wstring text = L"***Adapter: ";
        text += desc.Description;
        text += L"\n";

        OutputDebugString(text.c_str());

        adapterList.push_back(adapter);
        
        ++i;
    }

    for(size_t i = 0; i < adapterList.size(); ++i)
    {
        LogAdapterOutputs(adapterList[i]);
        ReleaseCom(adapterList[i]);
    }
}

void D3DApp::LogAdapterOutputs(IDXGIAdapter* adapter)
{
    UINT i = 0;
    IDXGIOutput* output = nullptr;
    while(adapter->EnumOutputs(i, &output) != DXGI_ERROR_NOT_FOUND)
    {
        DXGI_OUTPUT_DESC desc;
        output->GetDesc(&desc);
        
        std::wstring text = L"***Output: ";
        text += desc.DeviceName;
        text += L"\n";
        OutputDebugString(text.c_str());

        LogOutputDisplayModes(output, mBackBufferFormat);

        ReleaseCom(output);

        ++i;
    }
}

void D3DApp::LogOutputDisplayModes(IDXGIOutput* output, DXGI_FORMAT format)
{
    UINT count = 0;
    UINT flags = 0;

    // Call with nullptr to get list count.
    output->GetDisplayModeList(format, flags, &count, nullptr);

    std::vector<DXGI_MODE_DESC> modeList(count);
    output->GetDisplayModeList(format, flags, &count, &modeList[0]);

    for(auto& x : modeList)
    {
        UINT n = x.RefreshRate.Numerator;
        UINT d = x.RefreshRate.Denominator;
        std::wstring text =
            L"Width = " + std::to_wstring(x.Width) + L" " +
            L"Height = " + std::to_wstring(x.Height) + L" " +
            L"Refresh = " + std::to_wstring(n) + L"/" + std::to_wstring(d) +
            L"\n";

        ::OutputDebugString(text.c_str());
    }
}
```

- 创建 Command Object，主要包含 ID3D12CommandQueue、ID3D12CommandAllocator、ID3D12GraphicsCommandList。GPU 维护至少一个命令队列，命令列表封装了一系列图形渲染命令，Cpu可以利用(CommandList)将命令提交到这个队列中，命令分配器是一种和命令列表有关的内存管理类接口。记录命令列表内的命令，实际是存储在与之关联的命令分配器（CommandAllocator）上，当执行ID3D12CommandQueue::ExecuteCommandLists执行命令列表的时候，命令队列就用引用分配器里的命令。

```C++
void D3DApp::CreateCommandObjects()
{
	D3D12_COMMAND_QUEUE_DESC queueDesc = {};
	queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
	ThrowIfFailed(md3dDevice->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&mCommandQueue)));

	ThrowIfFailed(md3dDevice->CreateCommandAllocator(
		D3D12_COMMAND_LIST_TYPE_DIRECT,
		IID_PPV_ARGS(mDirectCmdListAlloc.GetAddressOf())));

	ThrowIfFailed(md3dDevice->CreateCommandList(
		0,
		D3D12_COMMAND_LIST_TYPE_DIRECT,
		mDirectCmdListAlloc.Get(), // Associated command allocator
		nullptr,                   // Initial PipelineStateObject
		IID_PPV_ARGS(mCommandList.GetAddressOf())));

	// Start off in a closed state.  This is because the first time we refer 
	// to the command list we will Reset it, and it needs to be closed before
	// calling Reset.
	mCommandList->Close();
}
```

- 创建 Swap Chain，IDXGISwapChain 提供了 IDXGISurface 用于存储 present 之前的渲染数据，使用 IDXGIFactory::CreateSwapChain 创建。这里传入了 command queue 方便进行 flush 操作（虽然我没看到有传 command queue 的 API 文档说明）

```C++
void D3DApp::CreateSwapChain()
{
    // Release the previous swapchain we will be recreating.
    mSwapChain.Reset();

    DXGI_SWAP_CHAIN_DESC sd;
    sd.BufferDesc.Width = mClientWidth;
    sd.BufferDesc.Height = mClientHeight;
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.BufferDesc.Format = mBackBufferFormat;
    sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
    sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
    sd.SampleDesc.Count = m4xMsaaState ? 4 : 1;
    sd.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - 1) : 0;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.BufferCount = SwapChainBufferCount;
    sd.OutputWindow = mhMainWnd;
    sd.Windowed = true;
	sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	// Note: Swap chain uses queue to perform flush.
    ThrowIfFailed(mdxgiFactory->CreateSwapChain(
		mCommandQueue.Get(),
		&sd, 
		mSwapChain.GetAddressOf()));
}
```

- 创建 RTV 和 DSV 描述符堆 ID3D12DescriptorHeap，使用 ID3D12Device::CreateDescriptorHeap 来创建

```C++
void D3DApp::CreateRtvAndDsvDescriptorHeaps()
{
    D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc;
    rtvHeapDesc.NumDescriptors = SwapChainBufferCount;
    rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
    rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	rtvHeapDesc.NodeMask = 0;
    ThrowIfFailed(md3dDevice->CreateDescriptorHeap(
        &rtvHeapDesc, IID_PPV_ARGS(mRtvHeap.GetAddressOf())));


    D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc;
    dsvHeapDesc.NumDescriptors = 1;
    dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
    dsvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	dsvHeapDesc.NodeMask = 0;
    ThrowIfFailed(md3dDevice->CreateDescriptorHeap(
        &dsvHeapDesc, IID_PPV_ARGS(mDsvHeap.GetAddressOf())));
}
```

- 综上，初始化 Direct3D 在我看来就是围绕 DXGI 和 Device 的一些创建操作，首先分别创建 DXGIFactory 和 Device，然后创建 Fence、CheckFeatureSupport、创建 Command Object、创建 Swap Chain、创建描述符堆，其中 DXGI 主要是用于枚举适配器和创建 swap chain 操作，device 主要创建渲染命令相关的内容

### D3DApp::FlushCommandQueue()

- 首先更新围栏值，然后添加一个 command ID3D12CommandQueue::Signal 用于前面的任务完成后更新围栏值，然后检查当前完成的围栏值是否小于最新的围栏值，如果小于则需要创建一个句柄，使用 ID3D12Fence::SetEventOnCompletion 用于当围栏值到达某个特定值后触发该 event，然后使用 WaitForSingleObject 等待该 event handle，最后 closehandle

```C++
void D3DApp::FlushCommandQueue()
{
	// Advance the fence value to mark commands up to this fence point.
	// 当前围栏值++
    mCurrentFence++;

    // Add an instruction to the command queue to set a new fence point.  Because we 
	// are on the GPU timeline, the new fence point won't be set until the GPU finishes
	// processing all the commands prior to this Signal().
	// 在 GPU 端将围栏对象设定为指定的值，需要等前面的 commands 都完成再执行
    ThrowIfFailed(mCommandQueue->Signal(mFence.Get(), mCurrentFence));

	// Wait until the GPU has completed commands up to this fence point.
    if(mFence->GetCompletedValue() < mCurrentFence)
	{
		HANDLE eventHandle = CreateEventEx(nullptr, false, false, EVENT_ALL_ACCESS);

        // Fire event when GPU hits current fence.  
		// 指定在围栏达到特定值时引发的事件，即 fence 到达下一个围栏值后会触发 event
        ThrowIfFailed(mFence->SetEventOnCompletion(mCurrentFence, eventHandle));

        // Wait until the GPU hits current fence event is fired.
		// 等待指定对象处于信号状态或超时间隔已过，然后关闭打开的对象句柄
		WaitForSingleObject(eventHandle, INFINITE);
        CloseHandle(eventHandle);
	}
}
```

- 总结一下同步 command 的逻辑：刷新围栏值设给 fence -> 检查围栏值，如果小于，创建 event handle，设置 fence 到达某个围栏值后触发该 event handle -> 等待该 event handle 触发，并 close handle

### D3DApp::OnResize()
 
- 进行 resize 操作之前首先进行 flush 操作，并使用 ID3D12GraphicsCommandList::Reset 将命令列表重置回其初始状态以及释放创建的资源：SwapChainBuffer、DepthStencilBuffer

```C++
assert(md3dDevice);
assert(mSwapChain);
assert(mDirectCmdListAlloc);

// Flush before changing any resources.
FlushCommandQueue();

// 将命令列表重置回其初始状态
ThrowIfFailed(mCommandList->Reset(mDirectCmdListAlloc.Get(), nullptr));

// Release the previous resources we will be recreating.
// 释放资源
for (int i = 0; i < SwapChainBufferCount; ++i)
	mSwapChainBuffer[i].Reset();
mDepthStencilBuffer.Reset();
```

- 使用 IDXGISwapChain::ResizeBuffers 重设 swapchain buffer size，创建相应的 RTV

```C++
// Resize the swap chain.
// 重设 swap chain 的大小，设置当前 backbuffer index
ThrowIfFailed(mSwapChain->ResizeBuffers(
	SwapChainBufferCount, 
	mClientWidth, mClientHeight, 
	mBackBufferFormat, 
	DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH));

mCurrBackBuffer = 0;
 
// 创建 RTV
CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHeapHandle(mRtvHeap->GetCPUDescriptorHandleForHeapStart());
for (UINT i = 0; i < SwapChainBufferCount; i++)
{
	ThrowIfFailed(mSwapChain->GetBuffer(i, IID_PPV_ARGS(&mSwapChainBuffer[i])));
	md3dDevice->CreateRenderTargetView(mSwapChainBuffer[i].Get(), nullptr, rtvHeapHandle);
	rtvHeapHandle.Offset(1, mRtvDescriptorSize);
}
```

- 创建 DS buffer 和 DSV

```C++
// Create the depth/stencil buffer and view.
// 创建 DS
D3D12_RESOURCE_DESC depthStencilDesc;
depthStencilDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
depthStencilDesc.Alignment = 0;
depthStencilDesc.Width = mClientWidth;
depthStencilDesc.Height = mClientHeight;
depthStencilDesc.DepthOrArraySize = 1;
depthStencilDesc.MipLevels = 1;

// Correction 11/12/2016: SSAO chapter requires an SRV to the depth buffer to read from 
// the depth buffer.  Therefore, because we need to create two views to the same resource:
//   1. SRV format: DXGI_FORMAT_R24_UNORM_X8_TYPELESS
//   2. DSV Format: DXGI_FORMAT_D24_UNORM_S8_UINT
// we need to create the depth buffer resource with a typeless format.  
depthStencilDesc.Format = DXGI_FORMAT_R24G8_TYPELESS;

depthStencilDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1;
depthStencilDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - 1) : 0;
depthStencilDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
depthStencilDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

D3D12_CLEAR_VALUE optClear;
optClear.Format = mDepthStencilFormat;
optClear.DepthStencil.Depth = 1.0f;
optClear.DepthStencil.Stencil = 0;
ThrowIfFailed(md3dDevice->CreateCommittedResource(
    &CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
	D3D12_HEAP_FLAG_NONE,
    &depthStencilDesc,
	D3D12_RESOURCE_STATE_COMMON,
    &optClear,
    IID_PPV_ARGS(mDepthStencilBuffer.GetAddressOf())));

// Create descriptor to mip level 0 of entire resource using the format of the resource.
// 创建 DSV
D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc;
dsvDesc.Flags = D3D12_DSV_FLAG_NONE;
dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
dsvDesc.Format = mDepthStencilFormat;
dsvDesc.Texture2D.MipSlice = 0;
md3dDevice->CreateDepthStencilView(mDepthStencilBuffer.Get(), &dsvDesc, DepthStencilView());
```

- 使用资源屏障同步资源状态 ResourceBarrier，然后使用 ID3D12GraphicsCommandList::Close() 标记 command list 结束，然后使用 ID3D12CommandQueue::ExecuteCommandList() 提交 command list 以执行，最后 flush 一下等待命令执行完毕

```C++
// Execute the resize commands.
// 标记 command list 结束并提交
ThrowIfFailed(mCommandList->Close());
ID3D12CommandList* cmdsLists[] = { mCommandList.Get() };
mCommandQueue->ExecuteCommandLists(_countof(cmdsLists), cmdsLists);

// Wait until resize is complete.
// 等待当前命令完成
FlushCommandQueue();
```

- D3D12_VIEWPORT 描述了视口的尺寸信息，D3D12_RECT 描述了 rect 信息，需要更新一下大小信息

```C++
// Update the viewport transform to cover the client area.
// 更新视口参数
mScreenViewport.TopLeftX = 0;
mScreenViewport.TopLeftY = 0;
mScreenViewport.Width    = static_cast<float>(mClientWidth);
mScreenViewport.Height   = static_cast<float>(mClientHeight);
mScreenViewport.MinDepth = 0.0f;
mScreenViewport.MaxDepth = 1.0f;

mScissorRect = { 0, 0, mClientWidth, mClientHeight };
```

- 总结来说，Resize() 操作主要涉及了 device、swapchain、commandlist 相关类，大致的流程：同步命令，清除 swap chain 和 depth stencil resource -> 重设 swapchain 缓冲区大小，并创建 RTV -> 创建 depth stencil buffer，并创建 DSV -> 使用资源屏障同步新创建的资源，提交命令并同步 -> 更新视口参数

### D3DApp::Initialize()

- D3D App 初始化就分为三步：窗口初始化 -> Direct 初始化 -> Resize

```C++
bool D3DApp::Initialize()
{
	// 创建窗口
	if(!InitMainWindow())
		return false;

	// 初始化 DirectX
	if(!InitDirect3D())
		return false;

    // Do the initial resize code.
	// 进行初始状态的 resize 操作
    OnResize();

	return true;
}
```

### BoxApp::BuildDescriptorHeaps()

- 虽然我们在 D3DApp 的初始化中创建了 Render Target & Depth Stencil，这些是必须的，但有的时候我们还需要 Constant Buffer，所以这里添加一个函数创建 BoxApp 需要的描述符堆

```C++
void BoxApp::BuildDescriptorHeaps()
{
    D3D12_DESCRIPTOR_HEAP_DESC cbvHeapDesc;
    cbvHeapDesc.NumDescriptors = 1;
    cbvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV; // The descriptor heap for the combination of constant-buffer, shader-resource, and unordered-access views
    cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	cbvHeapDesc.NodeMask = 0;
    ThrowIfFailed(md3dDevice->CreateDescriptorHeap(&cbvHeapDesc,
        IID_PPV_ARGS(&mCbvHeap)));
}
```

### BoxApp::BuildConstantBuffers()

- 使用 std::make_unique<UploadBuffer<ObjectConstants>>(md3dDevice.Get(), 1, true) 创建 Constant Buffer，并得到资源地址，然后使用 md3dDevice->CreateConstantBufferView() 创建 CBV

```C++
void BoxApp::BuildConstantBuffers()
{
    // 创建 UploadBuffer 供 CPU 写入，并计算缓冲区资源的 GPU 虚拟地址
	mObjectCB = std::make_unique<UploadBuffer<ObjectConstants>>(md3dDevice.Get(), 1, true);

	UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(sizeof(ObjectConstants));

	D3D12_GPU_VIRTUAL_ADDRESS cbAddress = mObjectCB->Resource()->GetGPUVirtualAddress();
    // Offset to the ith object constant buffer in the buffer.
    int boxCBufIndex = 0;
	cbAddress += boxCBufIndex*objCBByteSize;

    // 创建 CBV
	D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc;
	cbvDesc.BufferLocation = cbAddress;
	cbvDesc.SizeInBytes = d3dUtil::CalcConstantBufferByteSize(sizeof(ObjectConstants));

	md3dDevice->CreateConstantBufferView(
		&cbvDesc,
		mCbvHeap->GetCPUDescriptorHandleForHeapStart());
}
```






## 小结

## References

- [Introduction to 3D Game Programming with Direct3D 12.0](https://www.d3dcoder.net/)
- [Win32-HINSTANCE和HWND理解](https://www.cnblogs.com/autopwn/p/15493308.html)
- [CreateWindow函数详解](https://www.cnblogs.com/jjmcu/p/3881441.html?utm_source=tuicool&utm_medium=referral)
- [Win32 程序开发：窗口类结构体 WNDCLASS 和 WNDCLASSEX](https://www.cnblogs.com/linuxAndMcu/p/12075288.html)
- [Windows窗体之ShowWindow函数分析](https://blog.csdn.net/weixin_39768541/article/details/85490980)
- [ShowWindow 函数 (winuser.h)](https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-showwindow)
- [updateWindow 函数 (winuser.h)](https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-updatewindow)
- [UpdateWindow(hwnd)的意义?](https://bbs.csdn.net/topics/310148021)
- [adjustWindowRect 函数 (winuser.h)](https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nf-winuser-adjustwindowrect)
- [c++——HRESULT用法、实例](https://blog.csdn.net/liang841451955/article/details/80359362)
- [DXGI 概述](https://learn.microsoft.com/zh-cn/windows/win32/direct3ddxgi/d3d10-graphics-programming-guide-dxgi)