---
layout: post
title: "Vulkan（一）"
description: ""
date: 2023-7-3
feature_image: images/2023.7.3/0.png
tags: [Vulkan, C++]
---

<!--more-->

## LAYER

- 在 windows 中， 层被写在注册表中`HKEY_LOCAL_MACHINE\SOFTWARE\Khronos\Vulkan`，这里可以看到有一个 renderdoc 的 layer 信息

![](../images/2023.7.3/0.png)

- 当在 Vulkan 应用程序中，执行 `vkCreateInstance` 的时间，会加载 ICD 驱动文件
- 在后续的 loader_scanned_icd_add 调用中，代码从载入的库中获得了`vk_icdGetInstanceProcAddr` 函数指针并创建了入口的函数指针实例

```C++
loader_platform_open_library(const char * libPath)
loader_scanned_icd_add(...)
loader_icd_scan(...)
vkCreateInstance(...)
main()
```

- 整个流程就是，Vulkan Loader 扫描注册表获得相应的 json 文件，载入这个 json 文件，载入 dll，获得入口函数指针，载入相应函数指针。而这个载入过程，通过检查函数调用，也会在`vkEnumerateInstanceExtensionProperties` 等接口中调用。而SDK中的接口，都是对函数指针包了一层，例如 `vkCreateBuffer`，整个`VkLayerDispatchTable` 就是函数指针的集合

```C++
LOADER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL
vkCreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo,
               const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer) {
    const VkLayerDispatchTable *disp;

    disp = loader_get_dispatch(device);

    return disp->CreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
}
```

- vulkan 的一个思想就是，去除掉验证层，那么验证层能放在何处？也就是放在这个 SDK 里，类似各种 Graphic Debugger 的实现，Vulkan 有很多Validation Layer，可以根据需求载入，在真正的函数调用之前，截取一些信息，获得一些信息，最后再调用真正的接口。也就是说整个 SDK 不仅仅是一个函数指针获取器，还是一个 Graphic Debugger
- Vulkan是一个层架构，由Vulkan Application+Loader+Layer+ICDs(Installable Client Drivers) 组成，loader 可以插入一系列可选的layers

![](../images/2023.7.3/0.jpg)

- layers 是可选组件，可以增强 vulkan 系统，可以拦截，修改 vulkan api，layers 是作为 lib 库实现，可以通过不同方式使能并且在CreateInstance 中被加载。每个 layer 可以选择任何 vulkan api 进行拦截，一个 layer 不需要拦截所有 vulkan api function，layer 可以选择取拦截所有已知 vulkan api，也可以拦截一条 vulkan api。因为layer是可选的，我们可以在调试阶段使能，在release时关闭
- layer的一些示例如下：
    - 校验api使用
    - 增加debug和trace等调试信息
    - 覆盖额外内容
- vulkan 中很多扩展和函数（api）被分成两个主要组，一个是实例 instance 相关对象，另一个是 device 相关对象
- vulkan instance 是一个high-level系统级信息或者函数，vulkan对象如VkInstance和VkPhysicalDevice，vulkan函数如vkEnumerateInstanceExtensionProperties、vkEnumeratePhysicalDevices、vkCreateInstance、vkDestroyInstance等。可以使用vkGetInstanceProcAddr查询vulkan instance function，vkGetInstanceProcAddr可以查询device或者instance入口点，返回的函数指针对实例或者基于实例创建的对象有效，包括vkDevice对象，同理，instance扩展是一系列vulkan实例函数
- vulkan device是一个逻辑标识，别用于在特定physical device关联的api，device object有vkDevice，vkQueue，vkCommandBuffer，任何是前面三个object孩子的dispatchable object。device function一般是将device object作为第一个参数的api，比如vkQueueSubmit、vkBeginComandBuffer、vkCreateEvent等
- 任何 Vulkan function 都可能调用一组不同的模块经过 loader-layers-ICDs，loader 管理调度 Vulkan function 到正确的 layers 和 ICDs，Vulkan 的对象模型允许 loader 将 layers 插入到 call chain，所以可以在调用 ICDs 之前处理掉 Vulkan function
- layers 可以从 app 到 hardware 中拦截、评估和修改现有的 Vulkan functions，layers 被实现为可以以 lib 的形式被启用的库，并在 CreateInstance 期间加载，layer 可以选择 hook 哪些 function
- 要使用 layers 需要明确告知二进制文件的位置和要启用的层，layer 可以分别通过 loader/ application 进行隐式/显式启用，需要创建符合接口规范的 layer 才能让 loader 和 layer 之间正常通信，并且加载过程和 device & platform 都有关系

## Loader Interface Architecture



![](../images/2023.7.3/1.png)






## 小结

## References

- https://github.com/KhronosGroup/Vulkan-ValidationLayers/tree/main
- https://vulkan.lunarg.com/doc/sdk/1.3.250.1/linux/khronos_validation_layer.html
- https://www.cnblogs.com/vertexshader/articles/5225675.html
- https://zhuanlan.zhihu.com/p/584890426
- https://zhuanlan.zhihu.com/p/389646665
- https://www.lunarg.com/tutorial-overview-of-vulkan-loader-layers/
- https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/layers.adoc